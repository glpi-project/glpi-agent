package GLPI::Agent::Event;

use strict;
use warnings;

use English qw(-no_match_vars);

sub new {
    my ($class, %params) = @_;

    my $self = {};

    # Initialize from content generated by dump_for_message if required
    %params = %{$params{from_message}} if $params{from_message};

    # Check for supported events
    # 1. init:
    #  - init event are triggered when the service starts
    # 2. partial inventory:
    #  - can be trigerred by /now http requests
    #  - can be requested by glpi-inventory run via --partial parameter
    # 3. maintenance: internal event to trigger maintenance needs
    #  - for deploy, it cleans up storage from file parts when too old
    if ($params{init} && $params{init} =~ /^yes|1$/i) {
        # Partial inventory request on given categories
        $self = {
            _init    => 1,
            _task    => $params{task} // '',
            _name    => "init",
            _rundate => $params{rundate} // 0,
        };
    } elsif ($params{partial} && $params{partial} =~ /^yes|1$/i) {
        # Partial inventory request on given categories
        $self = {
            _partial  => 1,
            _task     => "inventory",
            _name     => "partial inventory",
            _category => $params{category} // '',
        };
        # Store any other params (can be used by database partial inventory requests)
        foreach my $key (grep { $_ ne 'partial' } keys(%params)) {
            $self->{_params}->{$key} = $params{$key} // "";
        }
    } elsif ($params{maintenance} && $params{maintenance} =~ /^yes|1$/i) {
        # Maintenance event on given task
        $self = {
            _maintenance => 1,
            _task        => $params{task} // '',
            _name        => $params{name} // "maintenance",
            _delay       => $params{delay} // 0,
        };
    }

    $self->{_target} = $params{target} if defined($params{target});

    bless $self, $class;

    return $self;
}

# Mandatory, event is invalid if not present
sub name {
    my ($self) = @_;
    return $self->{_name} // '';
}

# Event types

sub init {
    my ($self) = @_;
    return $self->{_init} // 0;
}

sub partial {
    my ($self) = @_;
    return $self->{_partial} // 0;
}

sub maintenance {
    my ($self) = @_;
    return $self->{_maintenance} // 0;
}

# Event attributes

sub task {
    my ($self) = @_;
    return $self->{_task} // '';
}

sub category {
    my ($self) = @_;
    return $self->{_category} // '';
}

sub target {
    my ($self) = @_;
    return $self->{_target} // '';
}

sub params {
    my ($self) = @_;
    return $self->{_params} // {};
}

sub delay {
    my ($self) = @_;
    return $self->{_delay} // 0;
}

sub rundate {
    my ($self, $rundate) = @_;

    $self->{_rundate} = $rundate if $rundate;

    return $self->{_rundate} // 0;
}

sub dump_as_string {
    my ($self) = @_;
    my $dump = $self->dump_for_message();
    return join("&", map { $_."=".(ref($dump->{$_}) || $dump->{$_}) } grep { ! ref($dump->{$_}) } keys(%{$dump}));
}

sub dump_for_message {
    my ($self) = @_;
    my $dump = {};
    foreach my $key (keys(%{$self})) {
        my ($name) = $key =~ /^_?(.*)$/;
        $dump->{$name} = $self->{$key} // "";
    }
    return $dump;
}

1;
